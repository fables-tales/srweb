//TITLE:	Query
//DESCRIPTION:	
//KEYWORDS:	
//CONTENT_TYPE:	markdown

Query {#query}
=====

<div class="warning">This documentation is currently out-of-date, and is in the process of being rewritten.  It should be completed within the next week or so.</div>

Often, you will need to wait on a particular event to occur; an input pin going high, for example. To do this, you will need to use `yield` (read [this](/docs/programming/python/yield_and_coroutines) to learn more). The API has changed slightly this year, making some things slightly clearer. In Python, it is possible to override operators (things like `*`, `+`, `<` and `==`, for example). We have used this feature to make compound waiting conditions more readable, as explained below.

[IO Queries](/docs/programming/sr/query/#IOQueries) {#IOQueries}
------------

There are a number of things you can `yield` on with `io`:

A digital input pin changing value (high to low, or low to high):

~~~
# Wait for digital input pin 3 on JointIO board 0 to change value
yield query.io[0].input[3].d
~~~

Waiting for a particular digital value:

~~~
# Wait for digital input 3 on JointIO board 0 to become digital '1'
yield query.io[0].input[3].d == 1
~~~

Waiting for an analogue pin to exceed a particular value:

~~~
# Wait for the reading of analogue input 3 on JointIO board 0 to exceed 1V
yield query.io[0].input[1].a > 1
~~~

Waiting for an analogue pin to drop below a particular value:

~~~
# Wait for the reading of analogue input 2 on JointIO board 0 to drop below 2.5V
yield query.io[0].input[2].a < 2.5
~~~

Code situated after these yields in the program flow will not be executed until the specified condition has been met. So, for example, if your robot had the following code:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
from sr import *

def main():

        # set output pin 0 high
        io[0].output[0].d = 1

        # wait until digital input 0 goes high
        yield query.io[0].input[0].d == 1

        # set output pin 0 low
        io[0].output[0] = 0
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

...when it was run, output pin 0 would be high and it would stay high until digital input pin 0 went high. When this happens, the next bit of code will execute &mdash; setting output pin 0 low.

Please note that you cannot wait on an analogue input using the equals (`==`) comparison. Because of the nature of analogue-digital conversion (as explained in the [io section](/docs/programming/sr/io#digital_vs_analogue)) it wouldn't make sense to do so.


[Vision Queries](/docs/programming/sr/query/#vision_queries) {#vision_queries}
----------------

Getting vision events is easy. All you need to do is:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# wait for a vision event to occur
ev = yield query.vision

if ev.was(vision):
        for blob in ev.vision.blobs:
                ...
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

See the [vision page](/docs/programming/sr/vision/) for more information.

[Combining Queries Together](/docs/programming/sr/query/#combining_queries) {#combining_queries}
----------------------------

When you write `query.io[0].input[0].d == 0` (for example), the operator overriding comes into play. But before that's explained, another explanation is necessary. When you write `abc = 1 == 1`, the value contained in `abc` afterwards is `True`. `abc` is assigned the value of the logical expression `1 == 1` &mdash; the boolean value, `True`. (If this is a surprise to you, then you should read a [tutorial](/docs/programming/python/).) 

This is where the confusing bit occurs &mdash; for the `query.(...)` objects, the operators are overridden so that they no longer compare values; they therefore don't return a boolean value, but another object instead. Because this object is just a representation for a condition that could be met, these conditions can be joined together.


### [More Complex Logic Expressions](/docs/programming/sr/query/#complex) {#complex}

Logic expressions can also be used with `yield`. You could, for example, wait until two conditions are met or perhaps any one of a range of conditions. Here are some examples:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# OR:
yield query.io[0].input[3].d == 1, query.io[0].input[2].d == 0
yield query.io[0].input[3].a > 2, query.io[0].input[3].a < 3

        
# AND:
yield (query.io[0].input[3].d == 1) & (query.io[0].input[2].d == 0)

# alternatively:
yield And( query.io[0].input[3].d == 1, query.io[0].input[2].d == 0 )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

AND means both inputs need to be `True` for execution to continue. OR means either one or both inputs need to be `True` for execution to continue.

If you decide to do this, however, you may need to find out which one occurred (if you're using OR, anyway). To do this, you would use something like the following:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ev = yield query.io[0].input[1].a > 1.6, (query.io[0].input[2].d == 1) & (query.io[0].input[3].d == 0)
if 2 in ev.io[0].pins:

    # ev.io[N].pins is a list of pins involved in the event
    # ev.io[N].vals is an array of the pin values
    # e.g. ev.io[0].vals[2] gives the value of the pin when the event happened
    # the value of ev.io[0].vals[0] is meaningless

    print ev.io[0].vals[2]

elif 1 in ev.io[0].pins:
    # ev.io.vals[1] is a voltage (float)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


### [Even More Complex Logical Expressions](/docs/programming/sr/query/#more_complex) {#more_complex}

So far, we've mainly used `io` for these querying expressions. It is possible to combine different types of querying objects into a single expression. It is possible to, say, wait for a switch to be closed for a maximum of 10 seconds and then carry on with your code regardless:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
from sr import *

def main():

        # set motor 0 to 20% power ahead
        motor[0].target = 20

        # wait for 10s or a button to be pressed, whichever's sooner.
        yield query.timeout(10), query.io[0].input[0].d == 1

        # stop the motor
        motor[0].target = 0
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Basically, the above code would turn a motor on for a maximum of 10 seconds, but stop it if input pin 0 went high (that sounds suspiciously like a bump sensor to me). In this case, we combined a `timeout` query and an `io` query.



